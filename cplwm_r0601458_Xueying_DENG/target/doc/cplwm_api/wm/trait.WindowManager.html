<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `WindowManager` trait in crate `cplwm_api`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, WindowManager">

    <title>cplwm_api::wm::WindowManager - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='../index.html'>cplwm_api</a>::<wbr><a href='index.html'>wm</a></p><script>window.sidebarCurrent = {name: 'WindowManager', ty: 'trait', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content trait">
<h1 class='fqn'><span class='in-band'>Trait <a href='../index.html'>cplwm_api</a>::<wbr><a href='index.html'>wm</a>::<wbr><a class='trait' href=''>WindowManager</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-496' class='srclink' href='../../src/cplwm_api/wm.rs.html#109-312' title='goto source code'>[src]</a></span></h1>
<pre class='rust trait'>pub trait WindowManager: <a class='trait' href='../../rustc_serialize/serialize/trait.Encodable.html' title='rustc_serialize::serialize::Encodable'>Encodable</a> + <a class='trait' href='../../rustc_serialize/serialize/trait.Decodable.html' title='rustc_serialize::serialize::Decodable'>Decodable</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> + <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> {
    type <a href='#associatedtype.Error' class='type'>Error</a>: <a class='trait' href='https://doc.rust-lang.org/nightly/std/error/trait.Error.html' title='std::error::Error'>Error</a> + 'static;
    fn <a href='#tymethod.new' class='fnname'>new</a>(screen: <a class='struct' href='../../cplwm_api/types/struct.Screen.html' title='cplwm_api::types::Screen'>Screen</a>) -&gt; Self;
    fn <a href='#tymethod.get_window_layout' class='fnname'>get_window_layout</a>(&amp;self) -&gt; <a class='struct' href='../../cplwm_api/types/struct.WindowLayout.html' title='cplwm_api::types::WindowLayout'>WindowLayout</a>;
    fn <a href='#tymethod.get_windows' class='fnname'>get_windows</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>&gt;;
    fn <a href='#tymethod.add_window' class='fnname'>add_window</a>(&amp;mut self, window_with_info: <a class='struct' href='../../cplwm_api/types/struct.WindowWithInfo.html' title='cplwm_api::types::WindowWithInfo'>WindowWithInfo</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;Self::Error&gt;;
    fn <a href='#tymethod.remove_window' class='fnname'>remove_window</a>(&amp;mut self, window: <a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;Self::Error&gt;;
    fn <a href='#tymethod.focus_window' class='fnname'>focus_window</a>(&amp;mut self, window: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>&gt;) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;Self::Error&gt;;
    fn <a href='#tymethod.cycle_focus' class='fnname'>cycle_focus</a>(&amp;mut self, dir: <a class='enum' href='../../cplwm_api/types/enum.PrevOrNext.html' title='cplwm_api::types::PrevOrNext'>PrevOrNext</a>);
    fn <a href='#tymethod.get_window_info' class='fnname'>get_window_info</a>(&amp;self, window: <a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='struct' href='../../cplwm_api/types/struct.WindowWithInfo.html' title='cplwm_api::types::WindowWithInfo'>WindowWithInfo</a>,&nbsp;Self::Error&gt;;
    fn <a href='#tymethod.get_screen' class='fnname'>get_screen</a>(&amp;self) -&gt; <a class='struct' href='../../cplwm_api/types/struct.Screen.html' title='cplwm_api::types::Screen'>Screen</a>;
    fn <a href='#tymethod.resize_screen' class='fnname'>resize_screen</a>(&amp;mut self, screen: <a class='struct' href='../../cplwm_api/types/struct.Screen.html' title='cplwm_api::types::Screen'>Screen</a>);

    fn <a href='#method.is_managed' class='fnname'>is_managed</a>(&amp;self, window: <a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a> { ... }
    fn <a href='#method.get_focused_window' class='fnname'>get_focused_window</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>&gt; { ... }
}</pre><div class='docblock'><p>A basic window manager.</p>

<p>Every window manager defined by a struct or enum representing its state,
must implement this trait.</p>

<h1 id='supertraits' class='section-header'><a href='#supertraits'>Supertraits</a></h1>
<p>Note what comes after <code>WindowManager:</code>, <code>Encodable + Decodable + Debug + Clone</code>. These are the “supertraits” of <code>WindowManager</code>: to implement this
trait, these four other traits must be implemented as well.</p>

<h2 id='encodable-and-decodable' class='section-header'><a href='#encodable-and-decodable'>Encodable and Decodable</a></h2>
<p>The first two, <code>Encodable</code> and <code>Decodable</code>, indicate that it should be
possible to serialise and deserialise a window manager. This functionality
is used in the backends, which allow reloading a live window manager
without losing its state. This is useful during development: one can
easily switch to a newly compiled version of the window manager without
losing all the state. Before reloading, the whole window manager is
serialised to JSON which is written to <code>/tmp</code>. The window manager is then
restarted from scratch. During startup, the window manager tries to read
this JSON, deserialises it and uses the result as the window manager,
including all the state instead of a new empty window manager. Windows
that have been added or removed since the state was saved will be added
and removed to/from the restored window manager.</p>

<p>All this is taken care of in the backend, so the only thing you have to do
is make sure your window manager is <code>Encodable</code> and <code>Decodable</code>. Lucky for
you, this traits can be derived <em>automatically</em> using the <code>derive</code>
annotation.</p>

<p>For example:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>RustcEncodable</span>, <span class='ident'>RustcDecodable</span>, ...)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>MyWM</span> {
    ...
}</pre>

<p>In the example, a struct <code>MyWM</code> with some fields is defined. The <code>derive</code>
annotation on the struct will implement both interfaces automatically for
you. In order for this to work, every field of the struct must implement
these interfaces too. Most basic types available in Rust (<code>i32</code>, <code>Vec</code>,
...) already implement this, but if you define additional structs, you
also have to put the same annotation on them.</p>

<p>Note that you can also implement these traits manually, but this will be a
lot more work.</p>

<h2 id='debug' class='section-header'><a href='#debug'>Debug</a></h2>
<p>The <code>Debug</code> trait is used to convert a window manager to a string
representation to print it during development, in test output or when
tracing.</p>

<p>This trait can also be derived automatically using <code>#[derive(Debug)]</code>.</p>

<h2 id='clone' class='section-header'><a href='#clone'>Clone</a></h2>
<p>The <code>Clone</code> is used to make a clone of a window manager.</p>

<p>This trait can also be derived automatically using <code>#[derive(Clone)]</code>.</p>

<h2 id='in-summary' class='section-header'><a href='#in-summary'>In Summary</a></h2>
<p>The example below demonstrates that you can implement these four traits
using one line of code:</p>

<pre class='rust rust-example-rendered'>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>RustcEncodable</span>, <span class='ident'>RustcDecodable</span>, <span class='ident'>Debug</span>, <span class='ident'>Clone</span>)]</span>
<span class='kw'>pub</span> <span class='kw'>struct</span> <span class='ident'>MyWM</span> {
    ...
}</pre>

<p>You also have to make sure that every type you use in the definition of
your window manager struct (or enum) also implements these four traits.</p>
</div>
            <h2 id='associated-types'>Associated Types</h2>
            <div class='methods'>
        <h3 id='associatedtype.Error' class='method stab '><code>type <a href='#associatedtype.Error' class='type'>Error</a>: <a class='trait' href='https://doc.rust-lang.org/nightly/std/error/trait.Error.html' title='std::error::Error'>Error</a> + 'static</code></h3><div class='docblock'><p>The type of the errors of the window manager.</p>

<p>You can define your own enum with different types of errors you window
manager can return. Many functions of this trait will return a
<code>Result&lt;(), Self::Error&gt;</code>: either an <code>Ok(())</code>, meaning that everything
went ok, or an <code>Err(err)</code> where <code>err</code> is of this <code>Error</code> type, meaning
that an error occurred.</p>

<p>Note the two “supertraits” your error type must implement:
<a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>error::Error</code></a>
and <code>&#39;static</code>. The first is the base trait for all Rust errors, click
on it to see the methods you must implement. This trait also has three
“supertraits”:</p>

<ul>
<li><code>Debug</code>: a <code>toString</code>-like method for debugging that can be derived
automatically using <code>#[derive(Debug, ...)]</code>.</li>
<li><code>Display</code>: a <code>toString</code>-like method that will be used to show error
to users (as opposed to developers). This method has to be manually
implemented.</li>
<li><code>Reflect</code>: you can safely ignore this.</li>
</ul>

<p>The second trait is not an actual trait, but a constraint that says
that your error must be static and should not contain any references
with a limited
<a href="https://doc.rust-lang.org/book/lifetimes.html">lifetime</a>. In other
words, your error type may not contain any type <code>&amp;&#39;a T</code>.</p>

<h1 id='examples' class='section-header'><a href='#examples'>Examples</a></h1>
<pre class='rust rust-example-rendered'>
<span class='doccomment'>/// Error type for my window manager</span>
<span class='attribute'>#[<span class='ident'>derive</span>(<span class='ident'>Debug</span>)]</span>  <span class='comment'>// Implement `Debug` automatically</span>
<span class='kw'>pub</span> <span class='kw'>enum</span> <span class='ident'>MyWMError</span> {
    <span class='doccomment'>/// This window is not known by the window.</span>
    <span class='ident'>UnknownWindow</span>(<span class='ident'>Window</span>),
    <span class='comment'>// Feel free to add more</span>
    ...
}
<span class='comment'>// Manually implement the `Display` trait.</span>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>fmt</span>;
<span class='kw'>impl</span> <span class='ident'>fmt</span>::<span class='ident'>Display</span> <span class='kw'>for</span> <span class='ident'>MyWMError</span> {
    <span class='kw'>fn</span> <span class='ident'>fmt</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>f</span>: <span class='kw-2'>&amp;</span><span class='kw-2'>mut</span> <span class='ident'>fmt</span>::<span class='ident'>Formatter</span>) <span class='op'>-&gt;</span> <span class='ident'>fmt</span>::<span class='prelude-ty'>Result</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='ident'>MyWMError</span>::<span class='ident'>UnknownWindow</span>(<span class='kw-2'>ref</span> <span class='ident'>window</span>) <span class='op'>=&gt;</span>
                <span class='macro'>write</span><span class='macro'>!</span>(<span class='ident'>f</span>, <span class='string'>&quot;Unknown window: {}&quot;</span>, <span class='ident'>window</span>),
            ...
        }
    }
}
<span class='comment'>// Now implement the `Error` trait.</span>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>error</span>;
<span class='kw'>impl</span> <span class='ident'>error</span>::<span class='ident'>Error</span> <span class='kw'>for</span> <span class='ident'>MyWMError</span> {
    <span class='kw'>fn</span> <span class='ident'>description</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) <span class='op'>-&gt;</span> <span class='kw-2'>&amp;</span><span class='lifetime'>&#39;static</span> <span class='ident'>str</span> {
        <span class='kw'>match</span> <span class='op'>*</span><span class='self'>self</span> {
            <span class='comment'>// Because we must return a `&amp;&#39;static str`, we can&#39;t</span>
            <span class='comment'>// include the window in it, because that creates a</span>
            <span class='comment'>// `String`.</span>
            <span class='ident'>MyWMError</span>::<span class='ident'>UnknownWindow</span>(_) <span class='op'>=&gt;</span> <span class='string'>&quot;Unknown window&quot;</span>,
        }
    }
}
<span class='comment'>// We can now use `MyWMError` as the `Error` type of the `MyWM` window</span>
<span class='comment'>// manager.</span>
<span class='kw'>impl</span> <span class='ident'>WindowManager</span> <span class='kw'>for</span> <span class='ident'>MyWM</span> {
    <span class='kw'>type</span> <span class='ident'>Error</span> <span class='op'>=</span> <span class='ident'>MyWMError</span>;
    ...
}</pre>

<p>Note that you can use the same error type in multiple window managers.</p>
</div></div>
            <h2 id='required-methods'>Required Methods</h2>
            <div class='methods'>
        <h3 id='tymethod.new' class='method stab '><code>fn <a href='#tymethod.new' class='fnname'>new</a>(screen: <a class='struct' href='../../cplwm_api/types/struct.Screen.html' title='cplwm_api::types::Screen'>Screen</a>) -&gt; Self</code></h3><div class='docblock'><p>The constructor of a window manager.</p>

<p>The sole argument is the <code>Screen</code>, useful to determine the size of
fullscreen windows or to center a window.</p>
</div><h3 id='tymethod.get_window_layout' class='method stab '><code>fn <a href='#tymethod.get_window_layout' class='fnname'>get_window_layout</a>(&amp;self) -&gt; <a class='struct' href='../../cplwm_api/types/struct.WindowLayout.html' title='cplwm_api::types::WindowLayout'>WindowLayout</a></code></h3><div class='docblock'><p>Return the current desired window layout.</p>

<p>For more information about this, see the assignment and the
documentation for <a href="../types/struct.WindowLayout.html"><code>WindowLayout</code></a>.</p>
</div><h3 id='tymethod.get_windows' class='method stab '><code>fn <a href='#tymethod.get_windows' class='fnname'>get_windows</a>(&amp;self) -&gt; <a class='struct' href='https://doc.rust-lang.org/nightly/collections/vec/struct.Vec.html' title='collections::vec::Vec'>Vec</a>&lt;<a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>&gt;</code></h3><div class='docblock'><p>Return a vector of all the windows managed by the window manager,
visible or not.</p>

<p>The order of the windows in the vector does not matter.</p>

<p><strong>Invariant</strong>: <code>get_windows()</code> must not contain duplicates.</p>
</div><h3 id='tymethod.add_window' class='method stab '><code>fn <a href='#tymethod.add_window' class='fnname'>add_window</a>(&amp;mut self, window_with_info: <a class='struct' href='../../cplwm_api/types/struct.WindowWithInfo.html' title='cplwm_api::types::WindowWithInfo'>WindowWithInfo</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;Self::Error&gt;</code></h3><div class='docblock'><p>Add a new window along with its information, e.g. its <code>Geometry</code>.</p>

<p>This is called whenever a new window is created.</p>

<p><strong>Invariant</strong>: <code>is_managed</code> must return true for the given window
after <code>add_window</code> was called with the given window.</p>

<p><strong>Invariant</strong>: after adding a window using <code>add_window</code>, it must be
focused according to <code>get_focused_window</code>.</p>

<p>A window manager that implements
<a href="trait.FloatSupport.html"><code>FloatSupport</code></a> should float the window when
the <code>float_or_tile</code> field of <code>WindowWithInfo</code> is set to <code>Float</code>.</p>

<p>A window manager that implements
<a href="trait.FullscreenSupport.html"><code>FullscreenSupport</code></a> should make the
window fullscreen when the <code>fullscreen</code> field of <code>WindowWithInfo</code> is
set to <code>true</code>.</p>

<p>This function is <em>allowed</em> to return an appropriate error when the
window is already managed by the window manager.</p>
</div><h3 id='tymethod.remove_window' class='method stab '><code>fn <a href='#tymethod.remove_window' class='fnname'>remove_window</a>(&amp;mut self, window: <a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;Self::Error&gt;</code></h3><div class='docblock'><p>Remove the given window from the window manager.</p>

<p>This is called whenever a window is destroyed/killed.</p>

<p>The same window remains focused, unless the focused window has been
removed.</p>

<p><strong>Invariant</strong>: <code>is_managed</code> must return false for the given window
after <code>remove_window</code> was called with the given window.</p>

<p>This function is <em>allowed</em> to return an appropriate error when the
window is not managed by the window manager.</p>
</div><h3 id='tymethod.focus_window' class='method stab '><code>fn <a href='#tymethod.focus_window' class='fnname'>focus_window</a>(&amp;mut self, window: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>&gt;) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>()</a>,&nbsp;Self::Error&gt;</code></h3><div class='docblock'><p>Focus the given window, or when passed <code>None</code>, focus nothing.</p>

<p>This is called when the user clicks or hovers on(to) a window, or
changes the focus using the keyboard.</p>

<p><strong>Invariant</strong>: when <code>focus_window</code> succeeds, <code>get_focused_window</code> must
return the same argument.</p>

<p>This function is <em>allowed</em> to return an appropriate error when the
window is not managed by the window manager.</p>
</div><h3 id='tymethod.cycle_focus' class='method stab '><code>fn <a href='#tymethod.cycle_focus' class='fnname'>cycle_focus</a>(&amp;mut self, dir: <a class='enum' href='../../cplwm_api/types/enum.PrevOrNext.html' title='cplwm_api::types::PrevOrNext'>PrevOrNext</a>)</code></h3><div class='docblock'><p>Focus the previous or next window.</p>

<p>Do nothing when there are no windows. When there is only one window,
focus it if currently no window is focused, otherwise do nothing.</p>

<p>When no window is focused, any window may become focused.</p>

<p>Cycling the focus back and forth shouldn&#39;t change the focused window.</p>
</div><h3 id='tymethod.get_window_info' class='method stab '><code>fn <a href='#tymethod.get_window_info' class='fnname'>get_window_info</a>(&amp;self, window: <a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/result/enum.Result.html' title='core::result::Result'>Result</a>&lt;<a class='struct' href='../../cplwm_api/types/struct.WindowWithInfo.html' title='cplwm_api::types::WindowWithInfo'>WindowWithInfo</a>,&nbsp;Self::Error&gt;</code></h3><div class='docblock'><p>Get the info (<code>WindowWithInfo</code>) belonging to the given window. It
should reflect the current state (location/size, floating or tiled,
fullscreen or not) of the window.</p>

<p>This method will come in handy when implementing later assignments by
defining wrappers around existing window managers.</p>

<p>This function <em>should</em> return an appropriate error when the window is
not managed by the window manager.</p>
</div><h3 id='tymethod.get_screen' class='method stab '><code>fn <a href='#tymethod.get_screen' class='fnname'>get_screen</a>(&amp;self) -&gt; <a class='struct' href='../../cplwm_api/types/struct.Screen.html' title='cplwm_api::types::Screen'>Screen</a></code></h3><div class='docblock'><p>Return the screen managed by the window manager.</p>
</div><h3 id='tymethod.resize_screen' class='method stab '><code>fn <a href='#tymethod.resize_screen' class='fnname'>resize_screen</a>(&amp;mut self, screen: <a class='struct' href='../../cplwm_api/types/struct.Screen.html' title='cplwm_api::types::Screen'>Screen</a>)</code></h3><div class='docblock'><p>Resize the screen according to the given <code>Screen</code>.</p>

<p>This is called whenever the resolution of the screen is changed.</p>

<p>Note that we do not support multiple monitors.</p>

<p><strong>Invariant</strong>: after <code>resize_screen</code> is called with a screen,
<code>get_screen()</code> must return the same screen.</p>
</div></div>
            <h2 id='provided-methods'>Provided Methods</h2>
            <div class='methods'>
        <h3 id='method.is_managed' class='method stab '><code>fn <a href='#method.is_managed' class='fnname'>is_managed</a>(&amp;self, window: <a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h3><div class='docblock'><p>Check whether a window is managed by this window manager.</p>

<p><strong>Invariant</strong>: <code>is_managed(w) == true</code> for some window <code>w</code> iff the
vector returned by the <code>get_windows</code> method contains <code>w</code>.</p>

<p>A default implementation is provided in terms of <code>get_windows</code>.
Override this implementation if you have a more efficient one.</p>
</div><h3 id='method.get_focused_window' class='method stab '><code>fn <a href='#method.get_focused_window' class='fnname'>get_focused_window</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='type' href='../../cplwm_api/types/type.Window.html' title='cplwm_api::types::Window'>Window</a>&gt;</code></h3><div class='docblock'><p>Return the window that is currently focused according to the window
manager.</p>

<p>If no window should be focused, return <code>None</code>.</p>

<p><strong>Invariant</strong>: <code>get_focused_window() == get_window_layout().focused_window</code>.</p>

<p><strong>Invariant</strong>: <code>get_focused_window() == Some(w)</code> then <code>is_managed(w) == true</code>.</p>

<p>A default implementation is provided in terms of <code>get_window_layout</code>
and its <code>focused_window</code> field. Override this implementation if you
have a more efficient one.</p>
</div></div>
        <h2 id='implementors'>Implementors</h2>
        <ul class='item-list' id='implementors-list'>
    </ul><script type="text/javascript" async
                         src="../../implementors/cplwm_api/wm/trait.WindowManager.js">
                 </script></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                    <dt>+</dt>
                    <dd>Collapse/expand all sections</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "cplwm_api";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script defer src="../../search-index.js"></script>
</body>
</html>